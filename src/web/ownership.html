<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
     <link rel="stylesheet" href="style.css" />
</head>
<body>
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake</h1>
<ul>
<li>
<a href="#toc_0">Ownership checks for C</a>
<ul>
<li>
<a href="#toc_1">One minute tour</a>
</li>
<li>
<a href="#toc_2">Move assignment</a>
</li>
<li>
<a href="#toc_3">structs/union/enum</a>
</li>
<li>
<a href="#toc_4">pointers</a>
</li>
<li>
<a href="#toc_5">destroying structs\unions</a>
</li>
<li>
<a href="#toc_6">Returning owner type</a>
</li>
<li>
<a href="#toc_7">Owner arrays</a>
</li>
<li>
<a href="#toc_8">Reality check I</a>
</li>
<li>
<a href="#toc_9">Reality check II</a>
</li>
<li>
<a href="#toc_10">Headers</a>
</li>
<li>
<a href="#toc_11">What&#39;s next?</a>
</li>
<li>
<a href="#toc_12">Conclusion</a>
</li>
<li>
<a href="#toc_13">Motivation</a>
</li>
</ul>
</li>
</ul>
<h1 id="toc_0">Ownership checks for C</h1>

<blockquote>
<p>This feature provides the experience of engaging in pair programming with an attentive developer who ensures program safety.</p>
</blockquote>

<h2 id="toc_1">One minute tour</h2>

<p>In the context of this feature, a <em>destructor</em> is a function called before an object&#39;s lifetime ends. The <em>lifetime</em> of an object refers to the period during which it is accessible and valid.</p>

<p>Introducing the new qualifier <em>owner</em>, which can be used to declare a type that requires the invocation of a <em>destructor</em> before the end of its lifetime.</p>

<p>For example, we can declare <code>malloc</code> as follows:</p>

<pre><code class="language-c">void * owner malloc(size_t sz);
</code></pre>

<p>To assign ownership to the result of <code>malloc</code>, we need to assign it to an <em>owner</em> variable:</p>

<pre><code class="language-c">int main() {
  void * owner p = malloc(1);
}
</code></pre>

<p>The compiler will generate an error message stating that the object &#39;p&#39; was not moved or destroyed.</p>

<p>To address this, we define a destructor for the object by declaring <code>free</code> as follows:</p>

<pre><code class="language-c">void free(void * owner p);
</code></pre>

<pre><code class="language-c">int main() {
  void * owner p = malloc(1);
  free(p); //p cannot be moved to free implicitly
}
</code></pre>

<p>The compiler informs us that &#39;p&#39; cannot be moved to <code>free</code> implicitly and suggests using <code>move</code> before the argument.</p>

<p>By explicitly using <code>move</code>, we indicate that the variable has been moved or destroyed at the caller&#39;s side.</p>

<pre><code>   free(move p);
</code></pre>

<p>The reason for that I want to make clear at the caller side that a variable has been moved/destroyed. </p>

<p>However, for certain functions with obvious move semantics based on their names, we can use the <code>[[implicit]]</code> attribute to make the usage of <code>move</code> optional:</p>

<pre><code class="language-c">void free([[implicit]] void * owner p);
</code></pre>

<p>I hope this brief tour provides you with a glimpse of what I aim to achieve.</p>

<h2 id="toc_2">Move assignment</h2>

<p>With the introduction of the <em>owner</em> qualifier, certain changes in the type system are necessary. Similar to being cautious and explicit when moving a variable into a function, we should adopt the same approach for assignments.</p>

<p>Consider this sample</p>

<pre><code class="language-c">int main() {
  void * p1 = malloc(1);
  void * p2 = malloc(1);
  p1 = p2;
  free(p1);
  free(p2);
}
</code></pre>

<p>In this case, assigning <code>p2</code> into <code>p1</code> leads to a memory leak of the <code>p1</code> object and a double free of the <code>p2</code> object.</p>

<p>To address this issue, the compiler will check the end of lifetime of <code>p1</code> before the assignment.  </p>

<p>The move assignment can be only used if both variables are owner.</p>

<p>The syntax is:</p>

<pre><code>p1 = move p2;
</code></pre>

<p>There is nothing especial on this assignment compared with the normal assignment. The only difference is that the intention is explicit. </p>

<p>After any move (assignment or function argument), the object transitions into an uninitialized state. This state is only for static analysis purposes and has no runtime implications.</p>

<p>Returning to our sample:</p>

<pre><code class="language-c">int main() {
  void * owner p1 = malloc(1);
  void * owner p2 = malloc(1);
  
  //error p1 was not moved or destroyed
  p1 = move p2;
  
  free(p1);
  free(p2);
}
</code></pre>

<p>The compiler will complain that <code>p1</code> was not moved or destroyed before the assignment. To resolve this, we modify the code as follows:</p>

<pre><code class="language-c">int main() {
  void * owner p1 = malloc(1);
  void * owner p2 = move p1;
  free(p2);
}
</code></pre>

<p>If you attempt to use <code>p1</code> after moving it, the compiler will issue a warning about using an uninitialized variable.</p>

<p>In some cases, it may not be possible to determine if an object is initialized or not. For such scenarios, the compiler suggests using options like assertions, the <code>[[uninitialized]]</code> attribute, or destroying the object before assignment.  </p>

<p>For instance:</p>

<pre><code class="language-c">struct X { char * owner name; };
void some_function(struct X * p) {
  //error: unknown p-&gt;name state
  p-&gt;name = strdup(&quot;new text&quot;);
}
</code></pre>

<p>In this case, the compiler will display a message stating that the state of <code>p-&gt;name</code> cannot be determined and provides suggestions for handling this situation:</p>

<p>This is how to fix it</p>

<pre><code class="language-c">  free(p-&gt;name);
  p-&gt;name = strdup(&quot;new text&quot;);
</code></pre>

<p>or
<code>c
  assert(p-&gt;name == NULL);
  p-&gt;name = strdup(&quot;new text&quot;);
</code>
or
<code>c
  [[unitialized]] p-&gt;name = move strdup(&quot;new text&quot;);
</code></p>

<p>We can assign a non owner to a owner.</p>

<pre><code class="language-c">  a = b; /* b is owner*/
</code></pre>

<p>In this situation the ownership is not transfered. The same think happens when we can function arguments that are not owners.</p>

<pre><code class="language-c">  void F(T a) {}
  owner T a;
  F(a); /*ownership is not transfered*/
</code></pre>

<h2 id="toc_3">structs/union/enum</h2>

<p>We can apply the <em>owner</em> qualifier to structs, unions, and enums as well:</p>

<pre><code class="language-c">int main() {
 owner struct X x = {};
}
</code></pre>

<p>This syntax works. However, if we forget to include the qualifier for an object that requires a destructor, we have a leak.</p>

<p>To address this, an additional syntax is provided for tagged objects:</p>

<pre><code class="language-c">struct owner X {
   ...
}
</code></pre>

<p>By using this syntax, the object is qualified as <em>owner</em> by default:</p>

<pre><code class="language-c">int main() {
   struct X x = {};    
} //**&quot;object &#39;x&#39; was not moved/destroyed&quot;**
</code></pre>

<h2 id="toc_4">pointers</h2>

<p>So far, the pointer samples have used <code>void *</code>. Now, let&#39;s consider the following situation:</p>

<pre><code class="language-c">struct owner X { char * owner name; };
int main() {
   struct X * owner p = new_x();    
}
</code></pre>

<p>Here, <code>p</code> is an <em>owner</em> pointer to an <em>owner</em> object. In this case, the pointer is the owner of both the memory and the object. Moving the pointer will transfer both responsibilities, resulting in the destruction of the object and the memory.</p>

<p>Consider this sample</p>

<pre><code class="language-c">
void x_delete([[implicit]] struct X * owner p) 
{
   if (p){
      p-&gt;free(name);
      free(p);
   }
}
int main() {
   struct X * owner p = new_x();
   x_delete(p);   
} 
</code></pre>

<p>This code demonstrates the same behavior as the following code:</p>

<pre><code class="language-c">int main() {
   struct X * owner p = new_x();
   if (p){
      p-&gt;free(name);
      free(p);
   }   
} 
</code></pre>

<p>Both scenarios require the same checks, indicating that there is nothing special about the destructors. </p>

<p>The compiler needs to check each <em>owner</em> member of the struct individually:</p>

<pre><code class="language-c">int main() {
   struct X * owner p = new_x();
   if (p){
      free(p-&gt;name);
      free(p);
   }   
} 
</code></pre>

<p>Having this logic in a specialized function makes the compiler&#39;s job easier, as the flow analysis becomes simpler. It&#39;s important to assist the compiler in order to leverage its capabilities.</p>

<p>Another detail to note is that when we free an <em>owner</em> pointer using <code>void *</code>, the compiler assumes that we are destroying the memory and not the pointed object. </p>

<p>If the pointed object is also an <em>owner</em>, the compiler checks if the object is destroyed first. In the provided sample, <code>free(p-&gt;name);</code> was the only <em>owner</em> member of the struct, so it was safe to call <code>free</code> on <code>p</code>.</p>

<h2 id="toc_5">destroying structs\unions</h2>

<p>Consider:</p>

<pre><code>struct owner X { char * owner name; };
void x_destroy([[implicit]] struct X x) 
{
   free(x.name);
}
int main() {
   struct X x;
   x_destroy(x);   
} 
</code></pre>

<p>This code is correct and works as expected.   </p>

<p>However, if we want to pass the struct using a pointer like:</p>

<pre><code>void x_destroy([[implicit]] struct X * owner p) {
   free(p-&gt;name);
}
</code></pre>

<p>The problem arises when we pass an <em>owner</em> pointer. The compiler assumes that we want to destroy both the object and the memory. However, in this case, the object is on the stack, and we only want to destroy the object, not to free the memory.</p>

<p>To address this, a qualifier called <code>obj_owner</code> is introduced, which can only be used for pointers:</p>

<pre><code>void x_destroy([[implicit]] struct X * obj_owner p) {
   free(p-&gt;name);
}
</code></pre>

<p>This qualifier indicates that the pointer is the owner of the object but not the owner of the memory.</p>

<h2 id="toc_6">Returning owner type</h2>

<p>Returning an <em>owner</em> variable is the same as moving it. The design decision here was not require the <code>move</code> keyword.</p>

<pre><code class="language-c">struct list make()
{
  struct list {...};
  return list; /*moved*/
}
</code></pre>

<h2 id="toc_7">Owner arrays</h2>

<p>As expected arrays and pointer are related.</p>

<p>The <em>owner</em> qualifier can be placed inside the array together with the array size:</p>

<pre><code class="language-c">void array_destroy(int n, struct X a[owner n])
{
}

int main()
{
  struct X a[owner 100];
  array_destroy(100, a);
}
</code></pre>

<p>We can also pass an <em>owner</em> pointer:</p>

<pre><code class="language-c">void array_destroy(int n, struct X a[owner n])
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_destroy(100, p);
  free(p);
}
</code></pre>

<p>By convention, passing an <em>owner</em> pointer to an array destructor will not transfer ownership of the memory, just of the pointed object.</p>

<p>To destroy both the array and the memory, we can use:</p>

<pre><code class="language-c">void array_delete(int n, struct X * owner p)
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_delete(100, p);  
}
</code></pre>

<h2 id="toc_8">Reality check I</h2>

<p>Let&#39;s examine how these rules can help with <code>fopen</code> and <code>fclose</code>.</p>

<pre><code class="language-c">FILE* owner fopen(char const* name,char const* mode);
int fclose([[implicit]] FILE* owner f);
</code></pre>

<pre><code class="language-c">int main() {
  FILE * owner p = fopen(&quot;text.txt&quot;, &quot;r&quot;);
  if (p) {
    fclose(p);
  }
}
</code></pre>

<p>In this scenario, we encounter a problem because not all control paths call the destructor. The compiler would emit a warning in such cases.</p>

<p>However, the code is correct because we don&#39;t need to and cannot call <code>fclose</code> on a null pointer.</p>

<p>To address this, null checks need to be implemented in the static analyzer. The compiler will not emit warnings if it can prove that an <em>owner</em> variable is empty or uninitialized at the end of its lifetime.</p>

<h2 id="toc_9">Reality check II</h2>

<pre><code class="language-c">int main()
{
  FILE * owner f = NULL;
  if (fopen_s( &amp;f,&quot;f.txt&quot;, &quot;r&quot;) == 0)  {
    fclose([[initialized]] f);
  }
  [[uninitialized]] f;
}
</code></pre>

<p>When initialization needs to be checked using a result code, we don&#39;t have semantics to provide the necessary information to the compiler. In this case, an annotation `</p>

<p>In this case, an annotation <code>[[initialized]]</code> is needed to inform the compiler that the variable is initialized, and an annotation <code>[[uninitialized]]</code> is needed to inform the compiler that the variable is uninitialized.</p>

<h2 id="toc_10">Headers</h2>

<p>move, owner, obj_owner and implicit can be defined as macros on <ownership.h>. (Similar of C99 did with bool _Bool)</p>

<pre><code class="language-c">#define move _Move
#define owner _Owner
#define obj_owner _Obj_owner
#define implicit [[implicit]]
</code></pre>

<p>Defining this macros to empty makes to code compatible with any compiler.</p>

<h2 id="toc_11">What&#39;s next?</h2>

<p>Implement this in cake.
<a href="http://thradams.com/cake/index.html">http://thradams.com/cake/index.html</a>
The hard part is the flow analysis.</p>

<h2 id="toc_12">Conclusion</h2>

<p>This feature aims to provide ownership checks in C by introducing the <em>owner</em> qualifier. It ensures that objects are properly destroyed or moved before their lifetime ends, preventing memory leaks and use-after-free errors. The compiler assists in detecting potential issues and suggests necessary changes to the code. By leveraging ownership checks, developers can write safer and more reliable code in C.</p>

<h2 id="toc_13">Motivation</h2>

<p>I have placed the motivation section at the end, considering that memory safety guarantees are already a widely discussed topic and the motivation becomes apparent as readers delve into the content.</p>

<p>In the C programming language, manual management of resources such as memory is necessary. We rely on functions like <code>malloc</code> to allocate memory and store the resulting address in a variable. To properly deallocate memory when it is no longer needed, we must use the address returned by <code>malloc</code> and call the <code>free</code> function.</p>

<p>Consequently, the variable holding the memory address is considered the owner of that memory. Discarding this address without calling <code>free</code> would result in a memory leak, which is an undesirable scenario.</p>

<p>Resource leaks present a significant challenge because they often remain silent problems, initially having no immediate impact on a program&#39;s behavior or causing immediate issues. These leaks can easily go unnoticed during unit tests, creating a false sense of security. It is crucial to address and track these problems early on. By doing so, we can not only prevent potential complications but also save valuable time and resources in the long run.</p>

<p>Moreover, these checks also help prevent occurrences of double free or use-after-free issues. While both problems typically lead to immediate failures at runtime, having preventive measures in place is highly advantageous.</p>
</body></html>